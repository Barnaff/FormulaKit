{
  "damage": "baseDamage * (1 + strength * 0.1)",
  "healthRegen": "baseRegen + vitality * 0.5",
  "expRequired": "100 * pow(level, 1.5)",
  "critDamage": "let isCrit = random() < critChance;\nisCrit ? baseDamage * 2 : baseDamage",
  "damageWithArmor": "let dmg = baseDamage * (1 + strength * 0.1);\nlet reduction = armor / (armor + 100);\ndmg * (1 - reduction)",
  "tieredBonus": "let mult;\nif (score >= 1000) { mult = 3 }\nelse if (score >= 500) { mult = 2 }\nelse { mult = 1 }\nbaseReward * mult",
  "fullDamage": "let weaponDmg = baseDamage * (1 + strength * 0.1);\nlet isCrit = random() < critChance;\n\nif (isCrit) {\n    weaponDmg *= 2\n}\n\nlet reduction = armor / (armor + 100);\nweaponDmg * (1 - reduction)",
  "quadraticSolution": "((-1*b)+sqrt((b^2)-(4*a*c)))/(2*a)",
  "quadraticSolutionNeg": "((-1*b)-sqrt((b^2)-(4*a*c)))/(2*a)",
  "cooldownWithHaste": "let hasteMult = max(0.5, 1 - hasteRating * 0.02);\nbaseCooldown * hasteMult",
  "staminaDrain": "let loadFactor = clamp(weight / capacity, 0, 2);\nbaseDrain * (1 + loadFactor * terrainModifier)",
  "dotDamage": "let tickDamage = baseTick * (1 + power * 0.05);\ntickDamage * duration / tickInterval",
  "lootDropChance": "let pity = min(pityStacks * 0.05, 0.5);\nbaseChance + luck * 0.01 + pity",
  "lerpedStat": "let ratio = clamp((time - startTime) / max(duration, 0.0001), 0, 1);\nstartValue + (endValue - startValue) * ratio"
}
